回顾:
1.方法的重写(Override):
  1)发生在父子类中，方法名相同，参数列表相同，方法体不同
  2)重写方法被调用时，看对象的类型
2.重写与重载的区别:
  1)重写:发生在父子类中，方法名相同，参数列表相同，方法体不同
         "运行期"绑定，看对象的类型来调用方法
  2)重载:发生在同一类中，方法名相同，参数列表不同，方法体不同
         "编译期"绑定，看引用的类型来绑定方法
3.package和import:
4.访问控制修饰符:
  1)public:公共的，任何类
  2)private:私有的，本类
  3)protected:受保护的，本类、子类、同包类
  4)默认的:什么也不写，本类、同包类
5.static:
  1)静态变量:static，类，方法区中，一份，类名点来访问
             所有对象所共享的资源(图片、音频、视频等)
  2)静态方法:static，类，方法区中，一份，类名点来访问
             没有隐式this传递，在静态方法中不能直接访问实例成员
			 方法的操作仅与参数相关而与对象无关
  3)静态块:static，类，类被加载时自动执行，一次
           初始化静态资源(图征、音频、视频等)
6.内存管理:JVM
  1)堆:存储所有new出来的对象(包括成员变量)
  2)栈:存储正在调用的方法中的所有局部变量(包括参数)
  3)方法区:存储.class字节码文件(包括方法、静态变量)


笔记:
1.final:最终的、不可改变的------单独应用的机率小
  1)修饰变量:变量不能被改变
  2)修饰方法:方法不能被重写
  3)修饰类:类不能被继承
2.static final:常量，应用率高
  1)必须声明同时初始化
  2)通过类名点来访问，不能被改变
  3)建议:常量名所有字母都大写，多个单词用_分隔
  4)编译器在编译时直接将常量替换为具体的值，效率高
3.抽象方法:
  1)由abstract修饰
  2)只有方法的定义，没有方法具体的实现(连{}都没有)
4.抽象类:
  1)由abstract修饰
  2)包含抽象方法的类必须是抽象类
    不包含抽象方法的类也可以声明为抽象类-----我乐意
  3)抽象类不能被实例化
  4)抽象类是需要被继承的，子类:
    4.1)重写所有抽象方法--------一般常规的用法
	4.2)也声明为抽象类----------不常用
  5)抽象类的意义:
    5.1)封装子类共有的属性和行为-------------代码复用
	5.2)为所有子类提供一种统一的类型---------向上造型
	5.3)可以包含抽象方法，为所有子类提供统一的入口
	    每个子类的实现不同，但入口是一致的
5.接口:
  1)是一个标准、规范------------制定方
    遵守了这个标准，就能干某件事------------API后
  2)接口是一种数据类型(引用类型)
  3)由interface定义
  4)只能包含常量和抽象方法
  5)接口不能被实例化
  6)接口是需要被实现的，实现类:
      必须重写接口中的所有抽象方法
  7)一个类可以实现多个接口，用逗号隔开
    若又继承又实现时，应先继承后实现
  8)接口可以继承接口






