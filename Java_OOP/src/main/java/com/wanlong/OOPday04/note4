回顾:
1.引用类型数组:
    Cell[] cells = new Cell[4]; //创建Cell数组对象
	cells[0] = new Cell(2,5); //创建Cell对象

	int[][] arr = new int[3][];
	arr[0] = new int[4];
2.继承:
    代码的复用，extends
	父类/基类:共有的
	子类/派生类:特有的
	子继承父后，子具有:父+子
	单一继承，传递性
	构造子之前必须先构造父，不写则默认super()调父类无参构造，
	自己写了则不再默认提供
3.super:指代当前对象的父类对象
   super.成员变量名:访问父类的成员变量
   super.方法名():调用父类的方法
   super():调用父类的构造方法
4.向上造型:
  1)父类型的引用指向子类的对象
  2)能点出来什么，看引用的类型

笔记:
1.方法的重写(Override):重新写、覆盖
  1)发生在父子类中，方法名称相同，参数列表相同，方法体不同
  2)重写方法被调用时，看对象的类型
2.重写与重载的区别:---------面试题
  1)重写(Override):
    1.1)发生在父子类中，方法名称相同，参数列表相同，方法体不同
	1.2)遵循"运行期绑定"，看对象的类型来调用方法
  2)重载(Overload):
    2.1)发生在一个类中，方法名称相同，参数列表不同，方法体不同
	2.2)遵循"编译期绑定"，看引用的类型来绑定方法
3.package:
  1)作用:避免类的命名冲突
  2)类的全称: 包名.类名
  3)包名可以有层次结构，同包中的类不能同名
  4)建议:包名所有字母都小写
  import:
  1)同包中的类可以直接访问
    不同包中的类不能直接访问，若想访问有如下两种方式:
	1.1)先import声明类再使用----建议
	1.2)类的全称----------------太繁琐，不建议
4.访问控制修饰符:
  1)public:公开的，任何类
  2)private:私有的，本类
  3)protected:受保护的，本类、子类、同包类
  4)默认的:什么也不写，本类、同包类
  类的访问修饰: public、默认的
  类中成员的访问修饰: 如上4种都可以
5.内存管理:由JVM管理---------------------了解
  1)堆:
    1.1)存储所有new出来的对象(包含成员变量)
	1.2)没有任何引用所指向的对象为垃圾，
	    垃圾回收器(GC)不定时到内存中清扫垃圾，
		回收过程是透明的，但不一定一发现垃圾就立即回收，
		调用System.gc()建议JVM尽快调度GC来回收垃圾
	1.3)内存泄漏:不再使用的内存还没有被及时的回收
	    建议:不再使用的对象及时将引用设置为null
	1.4)成员变量的生命周期:
	      创建对象时存在堆中，对象被回收时一并消失
  2)栈:
    2.1)存储正在调用中的方法的所有局部变量(包括参数)
	2.2)调用方法时，在栈中为该方法分配一块对应的栈帧，
	    栈帧中存储的是所有的局部变量(包括参数)，
		方法调用结束时，栈帧被清除，局部变量一并失效
	2.3)局部变量的生命周期:
	      调用方法时存在栈中，方法调用结束时与栈帧一并被清除
  3)方法区:
    3.1)存储的是.class字节码文件(包括方法、静态变量)
	3.2)方法只有一份，能过this来区分具体的对象
6.static:静态的
  1)静态变量:
    1.1)由static修饰
	1.2)属于类的，存储在方法区中，只有一份
	1.3)常常通过类名点来访问
	1.4)何时用:所有对象所共享的资源(图片、音频、视频等)
  2)静态方法:
    2.1)由static修饰
	2.2)属于类的，存储在方法区中，只有一份
	2.3)常常通过类名点来访问
	2.4)静态方法没有隐式this传递的，
	    静态方法中不能直接访问实例成员
	2.5)何时用:方法的操作仅与参数相关而与对象无关
  3)静态块:
    3.1)由static修饰
	3.2)属于类的，在类被加载时自动执行，
	    因为类中被加载一次，所以静态块也只执行一次
	3.3)何时用:加载/初始化静态资源(图片、音频、视频等)
