# JavaOOP
Java面向对象
回顾:
1.方法:函数、过程
    封装一段特定的业务逻辑功能
	尽可能的独立，一个方法只干一件事
	可以被反复调用多次
	减少代码重复，有利于代码维护，有利于团队协作开发
2.方法的定义:
    修饰词 返回值类型 方法名(参数列表){
	  方法体
	}
3.方法的调用:
  3.1)无返回值: 方法名(有参传参);
  3.2)有返回值: 数据类型 变量 = 方法名(有参传参);
                方法名(有参传参);---------不建议
4.return:
  4.1)return 值; 1)结束方法 2)返回结果给调用方
  4.2)return;    1)结束方法



笔记:
1.什么是类？什么是对象？
  1)现实世界是由很多很多对象组成的
    基于对象抽出了类
  2)对象:真实存在的单个的个体
    类:类别/类型，代表一类个体
  3)类中可以包含:
    3.1)所有对象所共有的属性/特征----------成员变量
	3.2)所有对象所共有的行为---------------方法
  4)一个类可以创建多个对象
    同一类型的多个对象，结构相同，数据不同
  5)类是对象的模板，对象是类的具体的实例
2.如何创建类？如何创建对象？如何访问成员？
3.引用类型之间画等号:
  1)指向同一个对象
  2)对其中一个引用的修改会影响另一个引用(对象只有一个)
    eg: 房子钥匙
  基本类型之间画等号:
  1)赋值
  2)对其中一个变量的修改不会影响另一个变量(数据是两份)
    eg: 身份证复印件
4.null:空，没有指向任何对象
       若引用的值为null，则该引用不能再进行任何操作了，
	   若操作则NullPointerException空指针异常

 
回顾:
1.什么是类？什么是对象？
2.如何创建类？如何创建对象？如何访问成员？
3.引用类型之间画等号:指向同一个对象 会影响
4.null:空，没有指向任何对象
       若引用的值为null，则该引用不能进行任何操作了，
	   若操作则NullPointerException空指针异常





正课:
1:方法的签名: 方法名+参数列表
2.方法的重载(Overload):
  1)发生在同一个类中，方法名称相同，参数列表不同
  2)编译器在编译时会根据方法的签名自动绑定方法
3.构造方法:
  1)常常用于给成员变量赋初值
  2)与类同名，没有返回值类型
  3)在创建(new)对象时被自动调用
  4)若自己不写构造方法，则编译器默认一个无参构造方法
    若自己写了构造方法，则不再默认提供
  5)构造方法可以重载
4.this:指代当前对象，哪个对象调用方法指的就是哪个对象
       只能用在方法中，方法中访问成员变量之前默认有个this.
  this的用法:
    1)this.成员变量名------------访问成员变量
	2)this.方法名()--------------调用方法
	3)this()---------------------调用构造方法
5.引用类型数组:

回顾:
1.方法的重载(Overload):
  1)发生在同一个类中，方法名称相同，参数列表不同
  2)编译器在编译时会根据方法的签名自动绑定方法
2.构造方法:构造函数、构造器、构建器
  1)给成员变量赋初值
  2)与类同名，没有返回值类型
  3)创建对象时被自动调用
  4)若自己不写，则默认无参构造，若自己写了，则不再默认提供了
  5)可以重载
3.this:指代当前对象，哪个对象调方法它指的就是哪个对象
       只能用在方法中，访问成员变量之前默认有个this.
  this的用法:
    1)this.成员变量名----------访问成员变量
	2)this.方法名()------------调用方法
	3)this()-------------------调用构造方法


笔记:
1.引用类型数组:
  1)Cell[] cells = new Cell[4];
    cells[0] = new Cell(2,5);
	cells[1] = new Cell(2,6);
	cells[2] = new Cell(2,7);
	cells[3] = new Cell(3,6);
  2)Cell[] cells = new Cell[]{
      new Cell(2,5),
	  new Cell(2,6),
	  new Cell(2,7),
	  new Cell(3,6)
    };
  3)int[][] arr = new int[3][];
    arr[0] = new int[2];
	arr[1] = new int[3];
	arr[2] = new int[2];
    arr[1][0] = 100; //给arr中第2个元素中的第1个元素赋值为100
  4)int[][] arr = new int[3][4];
    for(int i=0;i<arr.length;i++){
	  for(int j=0;j<arr[i].length;j++){
	    arr[i][j] = 100;
	  }
	}
2.继承:
  1)作用:实现代码的复用
  2)通过extends来实现继承
  3)父类:所有子类所共有的属性和行为
    子类:子类所特有的属性和行为
  4)子类继承父类后，子类具有:子类+父类
  5)一个父类可以有多个子类，
    一个子类只能继承一个父类----单一继承
  6)继承具有传递性
  7)java规定:构造子类之前必须先构造父类
    在子类构造中若自己不调用父类的构造，则默认super()调父类的无参构造
	若在子类构造中调用了父类的构造，则不再默认提供
	super()调用父类构造方法，必须位于子类构造的第一行
3.super:指代当前对象的父类对象
  super的用法:
    1)super.成员变量名----------访问父类的成员变量
	2)super.方法名()------------调用父类的方法
	3)super()-------------------调用父类的构造方法
4.向上造型:
  1)父类型的引用指向了子类的对象
  2)能点出来什么，看引用的类型
  
 回顾:
1.引用类型数组:
    Cell[] cells = new Cell[4]; //创建Cell数组对象
	cells[0] = new Cell(2,5); //创建Cell对象

	int[][] arr = new int[3][];
	arr[0] = new int[4];
2.继承:
    代码的复用，extends
	父类/基类:共有的
	子类/派生类:特有的
	子继承父后，子具有:父+子
	单一继承，传递性
	构造子之前必须先构造父，不写则默认super()调父类无参构造，
	自己写了则不再默认提供
3.super:指代当前对象的父类对象
   super.成员变量名:访问父类的成员变量
   super.方法名():调用父类的方法
   super():调用父类的构造方法
4.向上造型:
  1)父类型的引用指向子类的对象
  2)能点出来什么，看引用的类型

笔记:
1.方法的重写(Override):重新写、覆盖
  1)发生在父子类中，方法名称相同，参数列表相同，方法体不同
  2)重写方法被调用时，看对象的类型
2.重写与重载的区别:---------面试题
  1)重写(Override):
    1.1)发生在父子类中，方法名称相同，参数列表相同，方法体不同
	1.2)遵循"运行期绑定"，看对象的类型来调用方法
  2)重载(Overload):
    2.1)发生在一个类中，方法名称相同，参数列表不同，方法体不同
	2.2)遵循"编译期绑定"，看引用的类型来绑定方法
3.package:
  1)作用:避免类的命名冲突
  2)类的全称: 包名.类名
  3)包名可以有层次结构，同包中的类不能同名
  4)建议:包名所有字母都小写
  import:
  1)同包中的类可以直接访问
    不同包中的类不能直接访问，若想访问有如下两种方式:
	1.1)先import声明类再使用----建议
	1.2)类的全称----------------太繁琐，不建议
4.访问控制修饰符:
  1)public:公开的，任何类
  2)private:私有的，本类
  3)protected:受保护的，本类、子类、同包类
  4)默认的:什么也不写，本类、同包类
  类的访问修饰: public、默认的
  类中成员的访问修饰: 如上4种都可以
5.内存管理:由JVM管理---------------------了解
  1)堆:
    1.1)存储所有new出来的对象(包含成员变量)
	1.2)没有任何引用所指向的对象为垃圾，
	    垃圾回收器(GC)不定时到内存中清扫垃圾，
		回收过程是透明的，但不一定一发现垃圾就立即回收，
		调用System.gc()建议JVM尽快调度GC来回收垃圾
	1.3)内存泄漏:不再使用的内存还没有被及时的回收
	    建议:不再使用的对象及时将引用设置为null
	1.4)成员变量的生命周期:
	      创建对象时存在堆中，对象被回收时一并消失
  2)栈:
    2.1)存储正在调用中的方法的所有局部变量(包括参数)
	2.2)调用方法时，在栈中为该方法分配一块对应的栈帧，
	    栈帧中存储的是所有的局部变量(包括参数)，
		方法调用结束时，栈帧被清除，局部变量一并失效
	2.3)局部变量的生命周期:
	      调用方法时存在栈中，方法调用结束时与栈帧一并被清除
  3)方法区:
    3.1)存储的是.class字节码文件(包括方法、静态变量)
	3.2)方法只有一份，能过this来区分具体的对象
6.static:静态的
  1)静态变量:
    1.1)由static修饰
	1.2)属于类的，存储在方法区中，只有一份
	1.3)常常通过类名点来访问
	1.4)何时用:所有对象所共享的资源(图片、音频、视频等)
  2)静态方法:
    2.1)由static修饰
	2.2)属于类的，存储在方法区中，只有一份
	2.3)常常通过类名点来访问
	2.4)静态方法没有隐式this传递的，
	    静态方法中不能直接访问实例成员
	2.5)何时用:方法的操作仅与参数相关而与对象无关
  3)静态块:
    3.1)由static修饰
	3.2)属于类的，在类被加载时自动执行，
	    因为类中被加载一次，所以静态块也只执行一次
	3.3)何时用:加载/初始化静态资源(图片、音频、视频等)
  
  回顾:
1.方法的重写(Override):
  1)发生在父子类中，方法名相同，参数列表相同，方法体不同
  2)重写方法被调用时，看对象的类型
2.重写与重载的区别:
  1)重写:发生在父子类中，方法名相同，参数列表相同，方法体不同
         "运行期"绑定，看对象的类型来调用方法
  2)重载:发生在同一类中，方法名相同，参数列表不同，方法体不同
         "编译期"绑定，看引用的类型来绑定方法
3.package和import:
4.访问控制修饰符:
  1)public:公共的，任何类
  2)private:私有的，本类
  3)protected:受保护的，本类、子类、同包类
  4)默认的:什么也不写，本类、同包类
5.static:
  1)静态变量:static，类，方法区中，一份，类名点来访问
             所有对象所共享的资源(图片、音频、视频等)
  2)静态方法:static，类，方法区中，一份，类名点来访问
             没有隐式this传递，在静态方法中不能直接访问实例成员
			 方法的操作仅与参数相关而与对象无关
  3)静态块:static，类，类被加载时自动执行，一次
           初始化静态资源(图征、音频、视频等)
6.内存管理:JVM
  1)堆:存储所有new出来的对象(包括成员变量)
  2)栈:存储正在调用的方法中的所有局部变量(包括参数)
  3)方法区:存储.class字节码文件(包括方法、静态变量)


笔记:
1.final:最终的、不可改变的------单独应用的机率小
  1)修饰变量:变量不能被改变
  2)修饰方法:方法不能被重写
  3)修饰类:类不能被继承
2.static final:常量，应用率高
  1)必须声明同时初始化
  2)通过类名点来访问，不能被改变
  3)建议:常量名所有字母都大写，多个单词用_分隔
  4)编译器在编译时直接将常量替换为具体的值，效率高
3.抽象方法:
  1)由abstract修饰
  2)只有方法的定义，没有方法具体的实现(连{}都没有)
4.抽象类:
  1)由abstract修饰
  2)包含抽象方法的类必须是抽象类
    不包含抽象方法的类也可以声明为抽象类-----我乐意
  3)抽象类不能被实例化
  4)抽象类是需要被继承的，子类:
    4.1)重写所有抽象方法--------一般常规的用法
	4.2)也声明为抽象类----------不常用
  5)抽象类的意义:
    5.1)封装子类共有的属性和行为-------------代码复用
	5.2)为所有子类提供一种统一的类型---------向上造型
	5.3)可以包含抽象方法，为所有子类提供统一的入口
	    每个子类的实现不同，但入口是一致的
5.接口:
  1)是一个标准、规范------------制定方
    遵守了这个标准，就能干某件事------------API后
  2)接口是一种数据类型(引用类型)
  3)由interface定义
  4)只能包含常量和抽象方法
  5)接口不能被实例化
  6)接口是需要被实现的，实现类:
      必须重写接口中的所有抽象方法
  7)一个类可以实现多个接口，用逗号隔开
    若又继承又实现时，应先继承后实现
  8)接口可以继承接口
  
  回顾:
1.final:最终的、不可改变的
  1)修饰变量:变量不能被改变
  2)修饰方法:方法不能被重写
  3)修饰类:类不能被继承
2.static final:常量
  1)必须声明同时初始化
  2)类名点来访问，不能被改变
  3)大写，多个单词用_分隔
  4)编译器在编译时自动替换为具体的值
3.抽象方法:
  1)abstract
  2)只有方法的定义，没有方法体
4.抽象类:
    abstract，包含抽象方法的类必须是抽象类
    不能被实例化，是需要被继承的，子类:
	  1)重写所有抽象方法---变不完整为完整
	  2)也声明抽象类------不常用
	意义:封装共有的，统一的类型，
	     定义抽象方法，为所有子类提供统一的入口
5.接口:
    标准、规范，引用类型，interface定义，
	只能常量和抽象方法，不能被实例化
	需要被实现的，实现类:必须重写所有抽象方法
	一个类可以实现多个接口，用逗号隔开
	接口继承接口


正课:
1.多态:
  1)意义:
    1.1)同一类型的引用，指向不同的对象时，有不同的实现
	    -------行为的多态: cut()，run()，teach()...
	1.2)同一个对象，被造型为不同的类型时，有不同的功能
	    -------对象的多态: 我，你，水...
  2)向上造型:
    2.1)父类型的引用指向子类的对象
	2.2)能造型成为的类型有: 父类+所实现的接口
	2.3)能点出来什么，看引用的类型
  3)强制类型转换，成功的条件只有如下两种:
    3.1)引用所指向的对象，就是该类型
	3.2)引用所指向的对象，实现了该接口
  4)强转若不符合如上两个条件，则发生ClassCastException类型转换异常
    建议:在强转之前先使用instanceof来判断引用指向的对象是否是该类型
2.成员内部类:-----实际应用率低
  1)类中套类，外面的称为Outer外部类，里面的称为Inner内部类
  2)内部类通常只服务于外部类，对外不具备可见性
  3)内部类对象通常只能在外部类中创建
  4)内部类中可以直接访问外部类的成员(包括私有的)
    在内部类中有个隐式的引用指向了创建它的外部类对象
	  外部类名.this.
3.匿名内部类:
  1)若想创建一个类(子类)的对象，并且对象只需创建一个
    此时该类不必命名，称之为匿名内部类
  2)内部类中访问外部的变量，该变量必须是final的



面向对象三大特征:
1)封装:
  1.1)类:封装的是对象的属性和行为
  1.2)方法:封装的是具体的业务逻辑实现
  1.3)访问控制修饰符:封装的是访问的权限
2)继承:
  2.1)作用:代码的复用
  2.2)父类/基类:共有的属性和行为
      子类/派生类:特有的属性和行为
  2.3)子继承父之后，子具有:父+子
  2.4)传递性、单一继承，多接口实现
3)多态:
  3.1)意义:行为的多态、对象的多态
  3.2)向上造型、强制类型转换、instanceof判断
  3.3)多态的表现形式:
      3.3.1)重写:根据对象来多态
	  3.3.2)重载:根据参数来多态


面向对象课程安排:
第一天:
  1.什么是类?什么是对象?
  2.如何创建类？如何创建对象？如何访问成员？
  3.引用类型之间画等号
  4.null和NullPointerException
第二天:
  1.方法的重载
  2.构造方法
  3.this
  4.引用类型数组
第三天:
  1.内存管理:堆、栈、方法区
  2.继承
  3.super
  4.向上造型
第四天:
  1.方法的重写、重写与重载的区别
  2.package和import
  3.访问控制修饰符
  4.static
  5.final
  6.static final
第五天:
  1.抽象方法
  2.抽象类
  3.接口
第六天:
  1.多态:意义、向上造型、强制类型转换、instanceof
  2.内部类:成员内部类、匿名内部类
  
  
  
